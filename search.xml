<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>I am back</title>
    <url>/2023/11/12/I-am-back/</url>
    <content><![CDATA[<p>I am back !!!!</p>
<span id="more"></span>
<p>New day.New start!</p>
]]></content>
  </entry>
  <entry>
    <title>Java 中的getName(), getCanonicalName()和getSimpleName()</title>
    <url>/2018/08/09/getName-getCanonicalName-%E5%92%8CgetSimpleName/</url>
    <content><![CDATA[<p>先定义一个类和一个它的内部类:</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Name &#123;</span><br><span class="line">  class InnerClass &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void printName() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="外部类的差别"><a href="#外部类的差别" class="headerlink" title="外部类的差别"></a>外部类的差别</h1><p>先打印出Name 的getName(), getCanonicalName()和getSimpleName() 这三个的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(Name.class.getName());</span><br><span class="line">System.out.println(Name.class.getCanonicalName());</span><br><span class="line">System.out.println(Name.class.getSimpleName());</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.testjava.testclassname.Name</span><br><span class="line">com.testjava.testclassname.Name</span><br><span class="line">Name</span><br></pre></td></tr></table></figure>

<p>结论：可以看到对于一个外部类， getName() 和 getCanonicalName() 结果一样，都打印出了包含类的包名的路径，getSimpleName() 只打印出了不包含路径的简单的类名。</p>
<h1 id="内部类的差别"><a href="#内部类的差别" class="headerlink" title="内部类的差别"></a>内部类的差别</h1><p>打印逻辑如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(Name.InnerClass.class.getName());</span><br><span class="line">System.out.println(Name.InnerClass.class.getCanonicalName());</span><br><span class="line">System.out.println(Name.InnerClass.class.getSimpleName());</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.testjava.testclassname.Name$InnerClass</span><br><span class="line">com.testjava.testclassname.Name.InnerClass</span><br><span class="line">InnerClass</span><br></pre></td></tr></table></figure>

<p>结论：从结果看，getName() 使用了 <em>Name$InnerClass</em> 来标识InnerClass 是Name 的一个内部类，getCanonicalName() 则仍是打印出了和外部类一样的包名和路径，getSimpleName() 仍然只是打印出了简单的类名。</p>
<h1 id="匿名内部类的差别"><a href="#匿名内部类的差别" class="headerlink" title="匿名内部类的差别"></a>匿名内部类的差别</h1><p>打印逻辑如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyClassName &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    new Name() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      void printName() &#123;</span><br><span class="line">        System.out.println(this.getClass().getName());</span><br><span class="line">        System.out.println(this.getClass().getCanonicalName());</span><br><span class="line">        System.out.println(this.getClass().getSimpleName());</span><br><span class="line">        System.out.println(“print end”);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.printName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.testjava.testclassname.MyClassName$1</span><br><span class="line">null</span><br><span class="line"></span><br><span class="line">print end</span><br></pre></td></tr></table></figure>
<p>结论：对于一个匿名内部类，getName()打印出来的是MyClassName$1, getCanonicalName()对于一个匿名内部类打印出了null, getSimpleName() 的结果则是一个空的字符串。</p>
<h1 id="数组对象差别"><a href="#数组对象差别" class="headerlink" title="数组对象差别"></a>数组对象差别</h1><p>打印代码逻辑如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println((new Name[10]).getClass().getName());</span><br><span class="line">System.out.println((new Name[10]).getClass().getCanonicalName());</span><br><span class="line">System.out.println((new Name[10]).getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">System.out.println((new int[10]).getClass().getName());</span><br><span class="line">System.out.println((new int[10]).getClass().getCanonicalName());</span><br><span class="line">System.out.println((new int[10]).getClass().getSimpleName());</span><br></pre></td></tr></table></figure>

<p>输出结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Lcom.testjava.testclassname.Name;</span><br><span class="line">com.testjava.testclassname.Name[]</span><br><span class="line">Name[]</span><br><span class="line">[I</span><br><span class="line">int[]</span><br><span class="line">int[]</span><br></pre></td></tr></table></figure>
<p>结论：对于数组类型，getName()通过一个或者多个 <code>[</code> 来表示数组，<code>[</code> 后面紧接着的是元素类型；   getCanonicalName() 则是用 <code>[]</code> 来表示数组，对于基础类型则是直接显示出来；getName() 同样也用 <code>[]</code> 来表示数组类型.</p>
<blockquote>
<p>附：<br>getName()中提到的元素类型，对应关系如下所示:</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Element Type</th>
<th align="left">Encoding</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">Z</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">B</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">C</td>
</tr>
<tr>
<td align="left">class or interface</td>
<td align="left">Lclassname;</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">D</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">F</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">I</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">J</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">S</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hexo 的安装和配置</title>
    <url>/2023/11/12/hexo%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="hexo-的安装"><a href="#hexo-的安装" class="headerlink" title="hexo 的安装"></a>hexo 的安装</h2><h3 id="homebrew-的安装"><a href="#homebrew-的安装" class="headerlink" title="homebrew 的安装"></a>homebrew 的安装</h3><p>终端安装命令:</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>

<p>安装结束后，检测安装结果。终端检测命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brew doctor   </span><br><span class="line">//(输出 “Your system is ready to brew” 表示homebrew成功)</span><br></pre></td></tr></table></figure>

<h3 id="安装-Nodejs"><a href="#安装-Nodejs" class="headerlink" title="安装 Nodejs"></a>安装 Nodejs</h3><p>使用homebrew 安装Nodejs. 终端安装命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brew install node</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><p>mac 自带git, 此步跳过</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>终端安装命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo npm install -g hexo</span><br></pre></td></tr></table></figure>

<p>初始化hexo 到一个指定的目录(我的自定义目录为myhexo)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init myhexo</span><br></pre></td></tr></table></figure>

<p>进入myhexo， 进行安装npm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>安装完成后，可以输入下面命令开启 hexo 服务，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>开启之后在 本地地址可以进行预览 <a href="http://localhost:4000/">http://localhost:4000/</a>.</p>
<h2 id="关联github"><a href="#关联github" class="headerlink" title="关联github"></a>关联github</h2><p>在github 上面新建一个Repository，名字为${github用户名}.github.io, 例如: <strong>fuyouyushi.github.io</strong><br><br>在刚才创建的myhexo 文件下面打开 _config.xml 文件，在最后进行编辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/fuyouyushi/fuyouyushi.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>在myhexo 目录下执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>接下来执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>如果遇到提示 <strong>ERROR Deployer not found: git</strong>, 则先执行以下命令再执行<strong>hexo d</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>期间需要输入 github 的用户名和密码.<br><br>至此，可以利用github pages + hexo建立一个初步的个人博客。</p>
<h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><h3 id="下载Next-主题"><a href="#下载Next-主题" class="headerlink" title="下载Next 主题"></a>下载Next 主题</h3><p>hexo的主题网站<a href="https://hexo.io/themes/index.html">https://hexo.io/themes/index.html</a>. 里面列出了各种样式的主题。以<strong>Next</strong> 主题为例：<br><br>进入到Hexo 站点目录下(之前我创建的为myhexo 目录)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd myhexo</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>下载完成后，打开配置文件***_config.yml***, 修改theme 为next</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>之后命令行先进行clean, 再启动本地服务器可以在本地 <a href="http://localhost:4000/">http://localhost:4000/</a>, 预览next主题的效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo s -g</span><br></pre></td></tr></table></figure>

<h3 id="配置Next-主题"><a href="#配置Next-主题" class="headerlink" title="配置Next 主题"></a>配置Next 主题</h3><p>针对于Next 主题的配置需要修改的是 themes&#x2F;next 目录下的_config.yml 文件</p>
<h4 id="Scheme-配置"><a href="#Scheme-配置" class="headerlink" title="Scheme 配置:"></a>Scheme 配置:</h4><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观.</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
</ul>
<p>搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure>

<h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h4><p>修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是</p>
<ul>
<li>完整的互联网 URI， 例如 <a href="http://example.com/avatar.png">http://example.com/avatar.png</a></li>
<li>站点内的地址. 将头像放置主题目录下的 source&#x2F;uploads&#x2F; (新建 uploads 目录若不存在).配置为：avatar: &#x2F;uploads&#x2F;avatar.png; 或者 放置在 source&#x2F;images&#x2F; 目录下, 配置为：avatar: &#x2F;images&#x2F;avatar.png</li>
</ul>
<h2 id="TODO-list"><a href="#TODO-list" class="headerlink" title="TODO list:"></a>TODO list:</h2><ul>
<li>ssh 的添加</li>
</ul>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>编写一个Android本地Gradle插件</title>
    <url>/2018/07/10/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E6%9C%AC%E5%9C%B0Gradle%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>本文主要讲述如何创建一个可以在本地使用的 gradle 插件。具体步骤如下文所示:</p>
<span id="more"></span>


<h3 id="修改build-gradle"><a href="#修改build-gradle" class="headerlink" title="修改build.gradle"></a>修改build.gradle</h3><p>删除该 library 下的build.gradle 里面的内容， 修改为以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;groovy&#x27;</span><br><span class="line">apply plugin: &#x27;maven&#x27;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile gradleApi()</span><br><span class="line">    compile localGroovy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            pom.groupId = &#x27;com.test.plugin&#x27;</span><br><span class="line">            pom.version = &#x27;1.0.0&#x27;</span><br><span class="line">            pom.artifactId = &#x27;gradle-plugin-demo&#x27;</span><br><span class="line">            repository (url : uri(&#x27;../release&#x27;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中在uploadArchives中， pom.groupId定义了该插件的 groupId, pom.version 定义了插件的版本号，pom.artifactId 定义了插件的id。 repository (url : uri(‘..&#x2F;release’)) 标明插件会生成在本地的和JavaLibrary 平级的 release文件下。</p>
<h3 id="创建-Groovy-目录和-resources-目录"><a href="#创建-Groovy-目录和-resources-目录" class="headerlink" title="创建 Groovy 目录和 resources 目录"></a>创建 Groovy 目录和 resources 目录</h3><ol>
<li>从File -&gt; New Module… 中选择Java Library, 创建一个 JavaLibrary.</li>
<li>删除 src&#x2F;main 下面的所有文件夹和文件.</li>
<li>在 main 下面创建 groovy 目录，这个目录将用来放置之后编写的 gradle 插件的groovy 文件；</li>
<li>在 main 下面创建 resources 目录，之下依次创建 META-INF&#x2F;gradle-plugins 目录</li>
</ol>
<p>目录创建好之后如图所示：</p>
<img src="/2018/07/10/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E6%9C%AC%E5%9C%B0Gradle%E6%8F%92%E4%BB%B6/1.png" width="50%" height="50%" align="“left”/">

<h3 id="添加-Groovy-文件实现-和-properties-文件"><a href="#添加-Groovy-文件实现-和-properties-文件" class="headerlink" title="添加 Groovy 文件实现 和 properties 文件"></a>添加 Groovy 文件实现 和 properties 文件</h3><ul>
<li>在上一步创建好的文件下安装自己的习惯创建目录，并创建 groovy 文件，例如 DemoPlugin.groovy 文件。groovy 文件内容如下所示:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.demo</span><br><span class="line"></span><br><span class="line">import org.gradle.api.Plugin</span><br><span class="line">import org.gradle.api.Project;</span><br><span class="line"></span><br><span class="line">public class DemoPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line">        project.task(&#x27;demoPrint&#x27;) &lt;&lt; &#123;</span><br><span class="line">            println &#x27;this is a gradle plugin demo&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个文件主要内容是创建了一个 “demoPrint” 的task。这个task 进行的操作就是输出 “this is a gradle plugin demo” 这个信息。</p>
<ul>
<li>在之前创建 resources&#x2F;META-INF&#x2F;gradle-plugins 创建 properties 文件，文件的前缀应该保持和 pluginId 一致。比如之前我们创建的 pluginId 为pom.artifactId 的值“gradle-plugin-demo”，所以这里应该创建一个名为<br>gradle-plugin-demo.properties 的文件。文件内容如下所示，主要是声明了所实现的插件的路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation-class=com.demo.DemoPlugin</span><br></pre></td></tr></table></figure>

<p>经过以上两步之后，目录结构如下:</p>
<img src="/2018/07/10/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E6%9C%AC%E5%9C%B0Gradle%E6%8F%92%E4%BB%B6/2.png" width="50%" height="50%" align="“left”/">


<h3 id="生成本地的gradle-插件"><a href="#生成本地的gradle-插件" class="headerlink" title="生成本地的gradle 插件"></a>生成本地的gradle 插件</h3><p>由于在build.gralde 配置了 uploadArchives 的相关内容，所以可以在本次生成编写的gradle 插件。在该项目中的所有gradle任务中，可以看到如下的任务:</p>
<img src="/2018/07/10/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E6%9C%AC%E5%9C%B0Gradle%E6%8F%92%E4%BB%B6/3.png" width="50%" height="50%" align="“left”/">

<p>双击运行 uploadArchives任务，可以在之前定义的 release 目录下生成了本次的gradle 插件，内容如下图所示:</p>
<img src="/2018/07/10/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E6%9C%AC%E5%9C%B0Gradle%E6%8F%92%E4%BB%B6/4.png" width="50%" height="50%" align="“left”/">


<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>按照之前的步骤，已经在本次生成了gradle 插件。为了验证编写插件的正确性，可以把它添加到 app module中进行验证。打开 app 模块下的build.gradle, 修改为以下形式: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;com.android.application&#x27;</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url uri(&#x27;../release&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#x27;com.test.plugin:gradle-plugin-demo:1.0.0&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &#x27;gradle-plugin-demo&#x27;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>点击 “sync now” 进行同步之后，在命令行敲击 “.&#x2F;gradlew demoPrint”, 执行定义好的 demoPrint 任务，可以看到以下输出内容:</p>
<img src="/2018/07/10/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E6%9C%AC%E5%9C%B0Gradle%E6%8F%92%E4%BB%B6/5.png" width="50%" height="50%" align="“left”/">

<p>证明自己定义的task 确实生效了，得到了有效的执行。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在编写中遇到了 “Plugin id ‘gradle-plugin-demo’ not found” 之类的提示，后来经过排查发现是因为 “META-INF” 这个文件夹创建时放错了位置，我把它创建在了和main 平级的目录中，应当放在 main 文件夹下。所以相关的文件在创建时，要注意目录顺序。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
</search>
